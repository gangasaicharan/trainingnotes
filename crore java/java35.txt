LinkedHashMap
===============
It is a child class of HashMap class.

LinkedHashMap is exactly same as HashMap class with following differences.

HashMap					LinkedHashMap
-------					--------------
The underlying data structure is 	The underlying data structure is 
Hashtable.				Hashtable and LinkedList.

Insertion order is not preserved.	Insertion order is preserved.

It is introduced in 1.2v.		It is introduced in 1.4v.


ex:

import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		LinkedHashMap<String,String> lhm=new LinkedHashMap<String,String>();
		lhm.put("one","raja");
		lhm.put("nine","jose");
		lhm.put("six","alan");
		System.out.println(lhm);//{one=raja,nine=jose,six=alan}
		lhm.put("one","gogo");
		System.out.println(lhm);//{one=gogo,nine=jose,six=alan}
		lhm.put(null,null);
		System.out.println(lhm);//{one=gogo, nine=jose, six=alan, null=null}
	}
}

TreeMap
=======
The underlying data structure is RED BLACK TREE.

Duplicate keys are not allowed but values can be duplicated.

Insertion order is not preserved because it will take sorting order of the key.

If we depend upon default natural sorting order then keys must be 
homogeneous and Comparable.

If we depend upon customized sorting order then keys can be hetrogeneous and 
Non-Comparable.

Key can't be null but value can be null.

ex:
----
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		TreeMap<Integer,String> tm=new TreeMap<Integer,String>();
		tm.put(1,"one");
		tm.put(10,"ten");
		tm.put(5,"five");
		tm.put(7,"seven");
		tm.put(4,"four");
		System.out.println(tm);//{1=one, 4=four, 5=five, 7=seven, 10=ten}
		tm.put(6,null);
		System.out.println(tm);//{1=one, 4=four, 5=five, 6=null, 7=seven, 10=ten}
		tm.put(null,"nine");
		System.out.println(tm);//NullPointerException
	}
}

Hashtable
----------
The underlying data structure is Hashtable.

Duplicate keys are not allowed but values can be duplicated.

Insertion order is not preserved because it will take descending order of the key.

Hetrogeneous objects are allowed for both key and value.

Null insertion is not possible for both key and value.

ex:
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		Hashtable<Integer,String> ht=new Hashtable<Integer,String>();
		ht.put(1,"one");
		ht.put(10,"ten");
		ht.put(5,"five");
		ht.put(7,"seven");
		ht.put(4,"four");
		System.out.println(ht);//{10=ten, 7=seven, 5=five, 4=four, 1=one}
		ht.put(6,null);
		System.out.println(ht);//R.E NullPointerException 
		ht.put(null,"nine");
		System.out.println(ht);//R.E NullPointerException
	}
}

Types of cursors in java
======================
A cursor is used to retrieve an objects one by one from Collections.

We have three types of cursors in java.

1)Enumeration 

2)Iterator 

3)ListIterator 

1)Enumeration 
----------------
It is used to retrieve an objects one by one from legacy Collection objects.

We can create Enumeration object as follow.
ex:
	Enumeration e=v.elements();

Enumeration interface contains following two methods.
ex:
	public boolean hasMoreElements()
	public Object nextElement() 

ex:

import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		Vector v=new Vector();
		for(int i=1;i<=10;i++)
		{
			v.add(i);
		}
		System.out.println(v);//[1,2,3,4,5,6,7,8,9,10]

		Enumeration e=v.elements();
		while(e.hasMoreElements())
		{
			Integer i=(Integer)e.nextElement();
			System.out.println(i);
		}
	}
}

Limitations with Enumeration: 

> Enumeration is used to read objects one by one from legacy Collection
  objects only.Hence it is not a universal cursor.

> Enumeration interface is used to perform read operation but not remove   operation.
 
> To overcome this limitations Sun Micro System introduced Iterator.

2)Iterator
----------
It is used to read objects one by one from any Collection object.Hence it is a universal cursor.

Using Iterator interface we can perform read and remove operations.

We can create Iterator object as follow.
ex:
	Iterator itr=al.iterator();

Iterator interface contains following three methods.
ex:
	public boolean hasNext()
	public Object next()
	public void remove() 

ex:

import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		ArrayList al=new ArrayList();
		for(int i=1;i<=10;i++)
		{
			al.add(i);
		}
		System.out.println(al);//[1,2,3,4,5,6,7,8,9,10]

		Iterator itr=al.iterator();
		while(itr.hasNext())
		{
			Integer i=(Integer)itr.next();
			if(i%2==0)
				System.out.println(i);
			else
				itr.remove();
		}

		System.out.println(al);//[2,4,6,8,10]
	}
}

Limitations with Iterator interface:

> Using Enumeration and Iterator we can read the objects only in forward 
  direction but not in backward direction.Hence they are not bi-directional 
  cursors.

> Using Iterator interface we can perform read and remove operation but not 
  adding and replacement of new objects.

> To overcome this limitation Sun Micro System introduced ListIterator.


3)ListIterator
----------------
It is used to read objects one by one from List Collection objects only.

Using ListIterator interface we can perform read, remove, adding and replacement of new objects.

We can create ListIterator object as follow.

ex
	ListIterator litr=al.listIterator();

ListIterator object contains nine methods.

ex:
	public boolean hasNext()
	public Object next()
	public boolean hasPrevious()
	public Object previous()
	public void remove()
	public int previousIndex()
	public int nextIndex()
	public void set(Object o)
	public void add(Object o)
ex:
---
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		ArrayList al=new ArrayList();
		al.add("bala");
		al.add("nag");
		al.add("chiru");
		al.add("venki");
		System.out.println(al);//[bala, nag, chiru, venki]

		ListIterator litr=al.listIterator();
		while(litr.hasNext())
		{
			String s=(String)litr.next();
			System.out.println(s);
		}
	}
}

ex:
----
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		ArrayList al=new ArrayList();
		al.add("bala");
		al.add("nag");
		al.add("chiru");
		al.add("venki");
		System.out.println(al);//[bala, nag, chiru, venki]

		ListIterator litr=al.listIterator();
		while(litr.hasNext())
		{
			String s=(String)litr.next();
			if(s.equals("nag"))
			{
				litr.remove();
			}
		}
		System.out.println(al);//[bala, chiru, venki]
	}
}

ex:
----
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		ArrayList al=new ArrayList();
		al.add("bala");
		al.add("nag");
		al.add("chiru");
		al.add("venki");
		System.out.println(al);//[bala, nag, chiru, venki]

		ListIterator litr=al.listIterator();
		while(litr.hasNext())
		{
			String s=(String)litr.next();
			if(s.equals("nag"))
			{
				litr.add("chaitanya");
			}
		}
		System.out.println(al);//[bala, nag, chaitanya, chiru, venki]
	}
}

ex:
----
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		ArrayList al=new ArrayList();
		al.add("bala");
		al.add("nag");
		al.add("chiru");
		al.add("venki");
		System.out.println(al);//[bala, nag, chiru, venki]

		ListIterator litr=al.listIterator();
		while(litr.hasNext())
		{
			String s=(String)litr.next();
			if(s.equals("nag"))
			{
				litr.set("chaitanya");
			}
		}
		System.out.println(al);//[bala,chaitanya, chiru, venki]
	}
}

Diagram: java35.1


Interview Programs
====================

Q)Write a java program to display number of words present in a string?

input:
	This is is java java class 

output:
	This=1, is=2, java=2, class=1 


ex:

import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		String str="This is is java java class";

		LinkedHashMap<String,Integer> lhm=new LinkedHashMap<String,Integer>();

		String[] sarr=str.split(" ");

		for(String s:sarr)
		{
			if(lhm.get(s)!=null)
			{
				lhm.put(s,lhm.get(s)+1);
			}
			else
			{
				lhm.put(s,1);
			}
		}
		System.out.println(lhm);
	}
}

Q)Write a java program to check number of character present in string?

input:
	java

output:
	j=1,a=2,v=1 

ex:

import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		String str="java";

		LinkedHashMap<Character,Integer> lhm=new LinkedHashMap<Character,Integer>();

		char[] carr=str.toCharArray();

		for(char c:carr)
		{
			if(lhm.get(c)!=null)
			{
				lhm.put(c,lhm.get(c)+1);
			}
			else
			{
				lhm.put(c,1);
			}
		}
		System.out.println(lhm);
	}
}

Q)Write a java program to display given string is balanced or not?

input:
	str="{([])}"

output:
	It is balanced string 

ex:

import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		String str="{([])}";

		if(isBalanced(str))
			System.out.println("It is a balanced string ");
		else
			System.out.println("It is not balanced string ");

	}
	//callie method 
	public static boolean isBalanced(String str)
	{
		char[] carr=str.toCharArray();
		
		Stack<Character>  stack=new Stack<Character>();

		for(char ch:carr)
		{
			if(ch=='{' || ch=='(' || ch=='[')
				stack.push(ch);
			else if(ch=='}' && !stack.isEmpty() && stack.peek()=='{' )
				stack.pop();
			else if(ch==')' && !stack.isEmpty() && stack.peek()=='(' )
				stack.pop();
			else if(ch==']' && !stack.isEmpty() && stack.peek()=='[' )
				stack.pop();
			else
				return false;
		}
		
		return stack.isEmpty();		
	}
}

Q)Write a java program to display duplicate and unique elements from given array?

import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		int[] arr={2,4,6,3,7,7,9,8,9,9,1};
		
		Set<Integer> unique=new LinkedHashSet<Integer>();
		Set<Integer> duplicate=new LinkedHashSet<Integer>();

		for(int i:arr)
		{
			if(!unique.add(i))
			{
				duplicate.add(i);
			}
			unique.add(i);
		}
		System.out.println(unique);//[2, 4, 6, 3, 7, 9, 8, 1]
		System.out.println(duplicate);//[7, 9]
	}
}

Q)Write a java program to compare two dates?

import java.time.*;
class Test
{
	public static void main(String[] args) 
	{
		LocalDate date1=LocalDate.parse("2023-09-28");
		LocalDate date2=LocalDate.now();

		int result=date1.compareTo(date2);

		if(result<0)
			System.out.println("Date1 is less then Date2");
		else if(result>0)
			System.out.println("Date1 is gretest then Date2");
		else 
			System.out.println("Both are same");
	}
}









































































 














































































































