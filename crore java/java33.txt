Generics 
========
Arrays are typesafe.

We can provide guarantee what type of elements are present in array.

If requirement is there to store String values then it is recommanded to use String[] array.

ex:
	String[] sarr=new String[10];
	sarr[0]="hi";
	sarr[1]="hello";
	sarr[2]=10;  //C.T.E 

At the time of retrieving the data we don't need to perform any typecasting.
ex:
	String[] sarr=new String[10];
	sarr[0]="hi";
	sarr[1]="hello";
	-
	-
	String val=sarr[0];

Collections are not typesafe.

We can't provide guarantee that what type of elements are present in Collections.

If requirement is there to store String values then it is never recommanded to use ArrayList because we won't get any compile time error or runtime error but sometimes our programt get failure.
ex:
	ArrayList al=new ArrayList();
	al.add("hi");
	al.add("hello");
	al.add(10); 

At the time of retrieving the data compulsary we need to perform typecasting.
ex:
	ArrayList al=new ArrayList();
	al.add("hi");
	al.add("hello");
	al.add(10); 
	-
	-
	String val=(String)al.get(0);

To overcome this limitations our Sun Micro System introduced Generics concept 
in 1.5v.

The main objective of Generics are 

1) To make collectios as typesafe.

2) To avoid typecasting problem. 



java.util package
=================

Q)What is the difference between Arrays and Collections ?

Arrays					Collections
---------				-----------
Array is a collection of homogeneous	Collection is a collection of 
data elements.				homogeneous and hetrogenous data 
					elements.

Arrays are fixed in size.		Collections are growable in nature.

Performance point of view arrays are 	Memory point of view Collections are
recommanded to use.			recommanded to use.

Arrays are not implemented based on 	Collections are implemented based on
data structure concept so every logic	data structure concept so we can
we need to write the code explicitly	expect ready made methods.
we can't expect any readymade methods.

Array can hold primitive type or 	Collection can hold only object type.
object type.


Collection
==========
Collection is an interface which is present in java.util package.

It is a root interface for entire Collection Framework.

If we want to represent group of individual objects in a single entity then we need to use Collection interface.

Collection interface contains following methods.

ex:
  public abstract <T> T[] toArray(T[]);
  public abstract boolean add(E);
  public abstract boolean remove(java.lang.Object);
  public abstract boolean containsAll(java.util.Collection<?>);
  public abstract boolean addAll(java.util.Collection<? extends E>);
  public abstract boolean removeAll(java.util.Collection<?>);
  public boolean removeIf(java.util.function.Predicate<? super E>);
  public abstract boolean retainAll(java.util.Collection<?>);
  public abstract void clear();
  public abstract boolean equals(java.lang.Object);
  public abstract int hashCode();
  public java.util.Spliterator<E> spliterator();
  public java.util.stream.Stream<E> stream();
  and etc.


List
=======
It is a child interface of Collection interface.

If we want to represent group of individual objects in a single entity where duplicate objects are allowed and order is preserved then we need to use List interface.

Diagram: java33.1


ArrayList 
----------
The underlying data structure is resizable array or growable array.

Duplicate objects are allowed

Insertion order is preserved.

Hetrogeneous objects are allowed.

Null insertion is possible.

It implements Serializable, Cloneable and RandomAccess interface.

If our frequent operation is a retrieval operation then ArrayList is a best choice.

ex:1
----
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		ArrayList al=new ArrayList();
		al.add("one");
		al.add("two");
		al.add("three");
		System.out.println(al);//[one,two,three]
		al.add("one");
		System.out.println(al);//[one,two,three,one]
		al.add(10);
		System.out.println(al);//[one,two,three,one,10]
		al.add(null);
		System.out.println(al);//[one,two,three,one,10,null]
	}
}

ex:
----
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		ArrayList<String> al=new ArrayList<String>();
		al.add("one");
		al.add("two");
		al.add("three");
		System.out.println(al);//[one,two,three]
		al.add("one");
		System.out.println(al);//[one,two,three,one]
		al.add(null);
		System.out.println(al);//[one,two,three,one,null]
	}
}

ex:3
----
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		ArrayList<String> al=new ArrayList<String>();
		al.add("one");
		al.add("two");
		al.add("three");
	
		for(int i=0;i<al.size();i++)
		{
			System.out.println(al.get(i));
		}
	}
}

ex:
---
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		ArrayList<String> al=new ArrayList<String>();
		al.add("one");
		al.add("two");
		al.add("three");
	
		System.out.println(al.isEmpty());//false 

		System.out.println(al.contains("two"));//true 

		al.remove("two");

		System.out.println(al);//[one,three]

		al.clear();
		System.out.println(al);//[]

	}
}

ex:
---
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		List<String> list=new ArrayList<String>();
		list.add("one");
		list.add("two");
		list.add("three");
		System.out.println(list);//[one,two,three]
	}
}

ex:
---
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		List<Integer> list=Arrays.asList(4,7,1,9,5);

		System.out.println(list);//[4, 7, 1, 9, 5]
	}
}

LinkedList 
----------
The underlying data structure is dobly LinkedList.

Duplicate objects are allowed

Insertion order is preserved.

Hetrogeneous objects are allowed.

Null insertion is possible.

It implements Serializable, Cloneable and Deque interface.

If our frequent operation is a adding and removing in the middle then LinkedList is a best choice.

LinkedList contains following methods.

ex:
	addFirst()
	addLast()
	getFirst()
	getLast()
	removeFirst()
	removeLast()

ex:
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		LinkedList<String> ll=new LinkedList<String>();
		ll.add("one");
		ll.add("two");
		ll.add("three");
		System.out.println(ll);//[one,two,three]
		ll.add("one");
		System.out.println(ll);//[one,two,three,one]
		ll.add(null);
		System.out.println(ll);//[one,two,three,one,null]

	}
}

ex:
---
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		LinkedList<String> ll=new LinkedList<String>();
		ll.add("one");
		ll.add("two");
		ll.add("three");
		System.out.println(ll);//[one,two,three]

		ll.addFirst("gogo");
		ll.addLast("jojo");
		System.out.println(ll);//[gogo,one,two,three,jojo]

		System.out.println(ll.getFirst());//gogo
		System.out.println(ll.getLast());//jojo
		
		ll.removeFirst();
		ll.removeLast();
		System.out.println(ll);//[one,two,three]
	}
}

ex:
---
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		LinkedList<String> ll1=new LinkedList<String>();
		ll1.add("one");
		ll1.add("two");
		ll1.add("three");
		System.out.println(ll1);//[one,two,three]

		LinkedList<String> ll2=new LinkedList<String>();
		ll2.add("raja");
		System.out.println(ll2);//[raja]

		ll2.addAll(ll1);//[raja,one,two,three]

		System.out.println(ll2.containsAll(ll1));//true 

		ll2.removeAll(ll1);

		System.out.println(ll2);//[raja]
		
	}
}

Vector
=======
The underlying data structure is resizable array or growable array.

Duplicate objects are allowed

Insertion order is preserved.

Hetrogeneous objects are allowed.

Null insertion is possible.

It implements Serializable, Cloneable and RandomAccess interface.

All the methods present in Vector are synchronized methods.Hence we can achive thread safety.

Vector contains following methods.

ex:
	addElement()
	firstElement()
	lastElement()
	removeElementAt()
	removeAllElements() 
	and etc.

ex:
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		Vector<Integer> v=new Vector<Integer>();
		
		System.out.println(v.capacity());//10

		for(int i=1;i<=10;i++)
		{
			v.add(i);
		}
		System.out.println(v);//[1,2,3,4,5,6,7,8,9,10]
		
		System.out.println(v.get(0));
		System.out.println(v.get(v.size()-1));

		v.remove(5);
		System.out.println(v);//[1,2,3,4,5,7,8,9,10]

		v.clear();
		System.out.println(v);//[]
	
	}
}

ex:
---
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		Vector<Integer> v=new Vector<Integer>();
		
		System.out.println(v.capacity());//10

		for(int i=1;i<=10;i++)
		{
			v.addElement(i);
		}
		System.out.println(v);//[1,2,3,4,5,6,7,8,9,10]
		
		System.out.println(v.firstElement());
		System.out.println(v.lastElement());

		v.removeElementAt(5);
		System.out.println(v);//[1,2,3,4,5,7,8,9,10]

		v.removeAllElements();
		System.out.println(v);//[]
	
	}
}

Stack
=====
It is a child class of Vector class.

If we depends upon Last In First Out(LIFO) order then we need to use Stack.

constructor
-----------
Stack  s =new Stack();

methods
--------

push(Object o)
-------------
	It is used to push the element to stack.
pop()
----------
	It is used to remove the element from stack.
peek()
-------
	It is used to return toppest element from stack.

isEmpty()
----------
	It is used to check stack is empty or not.

search(Object o)
-----------------
	It will return offset value if element is present otherwise	
	it will return -1.

ex:
---
import java.util.*;
class Test
{
	public static void main(String[] args) 
	{
		Stack<String> s=new Stack<String>();
		s.push("A");
		s.push("B");
		s.push("C");
		System.out.println(s);//[A,B,C]

		s.pop();
		System.out.println(s);//[A,B]

		System.out.println(s.peek());//B 

		System.out.println(s.isEmpty());//false 

		System.out.println(s.search("Z")); // -1 

		System.out.println(s.search("A")); // 2 
	}
}



























































































































