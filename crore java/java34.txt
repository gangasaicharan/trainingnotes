Set
=====
It is a child interface of Collection interface.

If we want to represent group of objects in a single entity where duplicate objects are not allowed and order is not preserved then we need to use Set interface.

Diagram: java34.1


HashSet
---------
The underlying datastructure is Hashtable.

Duplicate objects are not allowed.

Insertion order is not preserved because it will store based on hash code of an object.

Hetrogeneous objects are allowed.

Null insertion is possible.

ex:

import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		HashSet hs=new HashSet();
		hs.add("one");
		hs.add("nine");
		hs.add("six");
		System.out.println(hs);//[nine,six,one]
		hs.add("one");
		System.out.println(hs);//[nine,six,one]
		hs.add(null);
		System.out.println(hs);//[null,nine,six,one]
		hs.add(10);
		System.out.println(hs);//[null, nine, six, one, 10]
	}
}

ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		HashSet<String> hs=new HashSet<String>();
		hs.add("one");
		hs.add("nine");
		hs.add("six");
		System.out.println(hs);//[nine,six,one]
		hs.add("one");
		System.out.println(hs);//[nine,six,one]
		hs.add(null);
		System.out.println(hs);//[null,nine,six,one]
	}
}


LinkedHashSet
---------------
It is a child class of HashSet class.

LinkedHashSet is a exactly same as HashSet class with following differences.

HashSet					LinkedHashSet
-----------				----------------
The underlying datastructure is 	The underlying datastructure is 
Hashtable.				Hashtable and LinkedList.

Insertion order is not preserved.	Insertion order is preserved.

It is introduced in 1.2v.		It is introduced in 1.4v.

ex:

import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		LinkedHashSet<String> lhs=new LinkedHashSet<String>();
		lhs.add("one");
		lhs.add("nine");
		lhs.add("six");
		System.out.println(lhs);//[one,nine,six]
		lhs.add("one");
		System.out.println(lhs);//[one,nine,six]
		lhs.add(null);
		System.out.println(lhs);//[one,nine,six,null]
	}
}

TreeSet 
---------
The underlying data structure is Balanced Tree.

Duplicate objects are not allowed.

Insertion order is not preserved  because it will take sorting order of an object.

Hetrogeneous objects are not allowed.If we try to insert then we will get ClassCastException.

For empty TreeSet if we try to insert null then we will get NullPointerException.

AFter inserting the elements if we try to insert null then we will get 
NullPointerException.

ex:
---

import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		TreeSet ts=new TreeSet();
		ts.add(10);
		ts.add(1);
		ts.add(5);
		ts.add(7);
		System.out.println(ts);//[1,5,7,10]
		ts.add(1);
		System.out.println(ts);//[1,5,7,10]
		//ts.add("hi");
		//System.out.println(ts);//R.E ClassCastException
		//ts.add(null);
		//System.out.println(ts);//R.E NullPointerException

	}
}

Q)What is the difference between Comparable and Comparator interface?


Comparable 
-----------
It is a interface which is present in java.lang package.

It contains only one method i.e compareTo() method.

If we depend upon default natural sorting order then we need to use Comparable interface.

ex:
		obj1.compareTo(obj2);


		It will return -ve if obj1 comes before obj2.
		It will return +ve if obj1 comes after obj2.
		It will return 0 if both objects are same.

ex:

class Test 
{
	public static void main(String[] args) 
	{
		System.out.println("A".compareTo("Z")); // -25
		System.out.println("Z".compareTo("A")); // 25
		System.out.println("K".compareTo("K")); // 0
	}
}

Comparator
----------
It is an interface which is present in java.util package.

It contains following two methods i.e equals() and compare() method.

ex:
	public abstract boolean equals(Object o);
	public abstract int compare(Object obj1,Object obj2);

If we depend upon customized sorting order then we need to use Comparator interface.

Implementation of equals() method is always optional because it is present in Object class  which is available to the program through inheritance.

Implementation of compare() method is mandatory.
ex:
	public int compare(Object obj1,Object obj2)

		It will return +ve if obj1 comes before obj2.
		It will return -ve if obj2 comes after obj2.
		It will return 0 if both objects are same.

ex:

import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		TreeSet<Integer> ts=new TreeSet<Integer>(new MyComparator());
		ts.add(10);
		ts.add(1);
		ts.add(5);
		ts.add(7);
		ts.add(3);
		System.out.println(ts);//[10,7,5,3,1]
	}
}
class MyComparator implements Comparator 
{
	public int compare(Object obj1,Object obj2)
	{
		Integer i1=(Integer)obj1;
		Integer i2=(Integer)obj2;
		if(i1<i2)
			return 1;
		else if(i1>i2)
			return -1;
		else
			return 0;
	}
}


ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		TreeSet<Integer> ts=new TreeSet<Integer>(new MyComparator());
		ts.add(10);
		ts.add(1);
		ts.add(5);
		ts.add(7);
		ts.add(3);
		System.out.println(ts);//[1,3,5,7,10]
	}
}
class MyComparator implements Comparator 
{
	public int compare(Object obj1,Object obj2)
	{
		Integer i1=(Integer)obj1;
		Integer i2=(Integer)obj2;
		if(i1<i2)
			return -1;
		else if(i1>i2)
			return 1;
		else
			return 0;
	}
}

Interview Question
==================
Q)Write a java program display distinct element from given array?

input:
	1 2 2 3 3 3 4 4 4 4

output:
	1 2 3 4 

ex:
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		int[] arr={1,2,2,3,3,3,4,4,4,4};

		Set<Integer> s=new LinkedHashSet<Integer>();

		//for each loop
		for(int i:arr)
		{
			s.add(i);
		}
		
		//converting Collection to Array
		int j=0;
		Integer[] resArr=new Integer[s.size()];
		for(Integer i:s)
		{
			resArr[j++]=i;
		}
		
		//display the data from array
		for(int i:resArr)
		{
			System.out.print(i+" ");
		}
		
	}	
}

Map
=====
It is a not a child interface of Collection interface.

If we want to represent group of individual objects in key,value pair then we need to use Map interface.

Both key and value must be objects.

Key can't be duplicated but value can be duplicated.

Key and value pair is called single entry or one entry.

Diagram: java34.2


HashMap
--------
The underlying data structure is Hashtable.

Keys can't be duplicated but values can be duplicated.

Insertion order is not preserved because it will take hash code of the key.

Hetrogeneous objects are allowed for both keys and values.

Null insertion is possible for both keys and values.

ex:

import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		HashMap hm=new HashMap();
		hm.put("one","raja");
		hm.put("nine","jose");
		hm.put("six","nelson");
		System.out.println(hm);//{nine=jose, six=nelson, one=raja}
		hm.put("one","gogo");
		System.out.println(hm);//{nine=jose, six=nelson, one=gogo}
		hm.put(null,null);
		System.out.println(hm);//{null=null, nine=jose, six=nelson, one=gogo}
		hm.put(10,100);
		System.out.println(hm);//{null=null, nine=jose, six=nelson, one=gogo, 10=100}
		
	}	
}

ex:
---
import java.util.*;
class Test 
{
	public static void main(String[] args) 
	{
		HashMap<String,String> hm=new HashMap<String,String>();
		hm.put("one","raja");
		hm.put("nine","jose");
		hm.put("six","nelson");
		
		Set s=hm.keySet();
		System.out.println(s);//[nine, six, one]

		Collection c=hm.values();
		System.out.println(c);//[jose, nelson, raja]

		Set s1=hm.entrySet();
		System.out.println(s1);//[nine=jose, six=nelson, one=raja]
	}	
}
















































































 





















































	























































































































