Accessing inner class data from static area of outer class
-----------------------------------------------------------
class Outer
{
	class Inner
	{
		//non-static methods
		public void m1()
		{
			System.out.println("Inner-M1 method");
		}
	}

	public static void main(String[] args)
	{
		Outer.Inner i=new Outer().new Inner();
		i.m1();
	}
}
Note:
----
Once if we compile above program we will get two .class file i.e Outer.class and Outer$Inner.class .

ex:
----
class Outer
{
	class Inner
	{
		//non-static methods
		public void m1()
		{
			System.out.println("Inner-M1 method");
		}
	}

	public static void main(String[] args)
	{
		new Outer().new Inner().m1();
	}
}

Accessing inner class data from non-static area of a outer class
----------------------------------------------------------
class Outer
{
	class Inner
	{
		//non-static methods
		public void m1()
		{
			System.out.println("Inner-M1 method");
		}
	}


	public void m2()
	{
		Inner i=new Inner();
		i.m1();
	}

	public static void main(String[] args)
	{
		Outer o=new Outer();
		o.m2();
	}
}

Interfaces
===========
Interface is a collection of zero or more abstract methods.

Abstract methods are incomplete methods because they end with semicolon and do not have any body.
ex:
	void m1();

It is not possible to create object for interfaces.

To write the implementation of abstract methods of an interface we will use implementation classes.

It is possible to create object for implementation because it contains method with body.

By default every abstract method is a public and abstract.
ex:
	public abstract void m1();

Interface contains only constants i.e public static and final.

syntax:
	interface <interface_name>
	{
		-
		- // constants
		- // abstract methods 
		-
	}

If we know only Service Requirement Specification then we need to use interface.

Diagram: java26.1

ex:1
-----
interface A 
{
	//abstract method
	public abstract void m1();
}
class B implements A 
{
	public void m1()
	{
		System.out.println("M1-Method");
	}
}
class Test
{
	public static void main(String[] args)
	{
		A a=new B();
		a.m1();
	}
}

ex:
----
interface A 
{
	//abstract method
	public abstract void m1();
}
class Test
{
	public static void main(String[] args)
	{
		A a=new A()
		{
			public void m1()
			{
				System.out.println("M1 Method");
			}
		};
		a.m1();
	}
}

If interface contains four methods then we need to override all methods otherwise we will get compile time error.

ex:
interface A 
{
	public abstract void show();
	public void display();
	abstract void view();
	void see();
}
class B implements A 
{
	public void show()
	{
		System.out.println("show-method");
	}
	public void display()
	{
		System.out.println("display-method");
	}
	public void view()
	{
		System.out.println("view-method");
	}
	public void see()
	{
		System.out.println("see-method");
	}
}
class Test
{
	public static void main(String[] args)
	{
		A a=new B();
		a.show();
		a.display();
		a.view();
		a.see();
	}
}

In java, a class can't extends more then one class simultenously.
But interface can extends more then one interface simultenously.

ex:

interface A 
{
	void m1();
}
interface B
{
	void m2();
}
interface C extends A,B 
{
	void m3();
}

class D implements C
{
	public void m1()
	{
		System.out.println("M1-method");
	}
	public void m2()
	{
		System.out.println("M2-method");
	}
	public void m3()
	{
		System.out.println("M3-method");
	}
}
class Test
{
	public static void main(String[] args)
	{
		C c=new D();
		c.m1();
		c.m2();
		c.m3();
	}
}

A class can implements more then one interface.
ex:
interface Father 
{
	float HT=6.2f;
	void height();
}
interface Mother 
{
	float HT=5.8f;
	void height();
}
class Child implements Father,Mother 
{
	public void height()
	{
		float height=(Father.HT+Mother.HT)/2;
		System.out.println("Child height is ="+height);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Child c=new Child();
		c.height();
	}
}



































